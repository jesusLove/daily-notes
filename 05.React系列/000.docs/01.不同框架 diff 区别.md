# 题目

> React 和 其他框架相比 diff 算法有什么不同 ？

# 解题技巧

原理题通常按照 **讲概念、说用途、理思路、列优缺** 的思路答题。

答题时采用 **先分类、后讲述** 的方式，层层递进得回答题目。

国内主要的框架有两个：React 和 Vue。例外还有一些类 React 框架，称为 React-like 框架，如 Preact。

答题框架：

1. React diff 算法完成 **讲概念、说用途、理思路、列优缺**。
2. 横向对比 React、React-like 框架及 Vue 的 diff 算法。

# 入手

## Diff 算法

diff 算法是建立在虚拟 DOM 的基础上的。Diff 算法的功能就是虚拟 DOM 树发生改变，如何以最小成本完成新旧两株 DOM 树的更新补丁，完成视图更新。

新 VDOM
===> 差异 VDOM =更新=> 真实 DOM ===> 视图更新
旧 VDOM

> VDOM 和 真实 DOM 之间有映射关系，当 VDOM 发生改变时，计算插件生成 Patch 补丁，然后根据 Patch 更新真实的 DOM，反馈到界面上。

## 更新时机

触发更新、差异对比的时机是 setState 、Hooks 调用等操作后。

## 遍历算法

遍历算法就是对 DOM 树的遍历，通常两种：深度优先遍历和广度优先遍历。

- 深度优先遍历，是从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点。
- 广度优先遍历，则是从根节点出发，在横向遍历二叉树层段节点的基础上，纵向遍历二叉树的层次。

React diff 采用深度优先遍历的方式，广度优先会导致组件生命周期错乱。

## 优化策略

React 采用有 分治 的思想优化 Diff 算法，复杂度为 O(n)。

React 分别从树、组件以及元素三个层面进行复杂度的优化

### 策略一 忽略节点跨层级操作场景，提升比对效率。

这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。

### 策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。

在组件比对的过程中：如果组件是同一类型则进行树比对；如果不是则直接放入补丁中。

只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。

### 策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。

元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用

### Fiber

Fiber 机制节点与树分别采用 FiberNode 与 FiberTree 进行重构。

FiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点，使得整个更新过程可以随时暂停恢复。FiberTree 则是通过 FiberNode 构成的树。

Fiber 机制下，整个更新过程由 current 与 workInProgress 两株树双缓冲完成。

当 workInProgress 更新完成后，通过修改 current 相关指针指向的节点，直接抛弃老树，虽然非常简单粗暴，却非常合理

# Vue

Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。

# 优化代码

- 使用 shouldComponentUpdate、PureComponent 及 React.memo 减少 diff 次数
- 设置唯一的 key ，避免深层嵌套。

# 总结

在回答有何不同之前，首先需要说明下什么是 diff 算法。

diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。

React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。

- 树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。
- 组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。
- 元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。

以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。

整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。

然后拿 Vue 和 Preact 与 React 的 diff 算法进行对比。

Preact 的 Diff 算法相较于 React，整体设计思路相似，但最底层的元素采用了真实 DOM 对比操作，也没有采用 Fiber 设计。Vue 的 Diff 算法整体也与 React 相似，同样未实现 Fiber 设计。

然后进行横向比较，React 拥有完整的 Diff 算法策略，且拥有随时中断更新的时间切片能力，在大批量节点更新的极端情况下，拥有更友好的交互体验。

Preact 可以在一些对性能要求不高，仅需要渲染框架的简单场景下应用。

Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。
